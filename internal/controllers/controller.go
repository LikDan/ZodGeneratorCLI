package controllers

import (
	"bufio"
	"context"
	"errors"
	"os"
	"path/filepath"
	"strings"
	"zodGeneratorCLI/internal/models"
	"zodGeneratorCLI/pkg/filesutils"
)

type Controller interface {
	Generate(ctx context.Context, workingDir string, recursive bool, files []string) error
}

type controller struct {
	autogeneratedText   string
	fileToGeneratedText string

	parser Parser
	zod    Zod
}

func NewController() Controller {
	return &controller{
		autogeneratedText:   "//autogenerated using zod-cli",
		fileToGeneratedText: "//zod-cli generate",
		parser:              NewParser(),
		zod:                 NewZod(),
	}
}

func (c *controller) Generate(ctx context.Context, workingDir string, recursive bool, files []string) error {
	workingDir, err := filepath.Abs(workingDir)
	if err != nil {
		return err
	}

	files, err = c.getFilesToGenerate(workingDir, recursive, files)
	if err != nil {
		return err
	}

	parsedFiles, err := c.parser.ParseFiles(ctx, files)
	if err != nil {
		return err
	}

	zodModels, err := c.zod.Convert(ctx, parsedFiles)
	if err != nil {
		return err
	}

	return c.save(zodModels)
}

func (c *controller) getFilesToGenerate(workingDir string, recursive bool, input []string) ([]string, error) {
	if len(input) != 0 {
		return input, nil
	}

	input, err := filesutils.FindByFunc(workingDir, recursive, func(path string) bool {
		if !strings.HasSuffix(path, ".ts") {
			return false
		}

		file, _ := os.Open(path)
		defer func(file *os.File) { _ = file.Close() }(file)

		scanner := bufio.NewScanner(file)
		scanner.Scan()
		line := scanner.Text()

		return line == c.fileToGeneratedText
	})
	if err != nil {
		return nil, err
	}

	if len(input) == 0 {
		return nil, errors.New("no files")
	}

	return input, nil
}

func (c *controller) save(files []models.ZodFile) error {
	for _, file := range files {
		filename := file.Path

		builder := strings.Builder{}
		builder.WriteString(c.autogeneratedText + "\nimport { z } from 'zod';\n")

		for _, tsImport := range file.Imports {
			builder.WriteString(tsImport.Raw(file.Path))
			builder.WriteString("\n")
		}

		for _, model := range file.Models {
			builder.WriteString("\n")
			builder.WriteString(model.Raw)
			builder.WriteString("\n")
		}

		if err := os.MkdirAll(filepath.Dir(filename), 0777); err != nil {
			return err
		}

		if err := os.WriteFile(filename, []byte(builder.String()), 0777); err != nil {
			return err
		}
	}

	return nil
}
